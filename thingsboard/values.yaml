nameOverride:
fullNameOverride:
imagePullSecrets:
# - name: "image-pull-secret"

setup:
  enabled: false
  kind: install
  fromVersion:
  kafka: false
  kafkaServer:

node:
  enabled: true
  kind: Deployment
  # only used if kind is Deployment
  replicas: 1
  name: tb-node
  nameOverride: null
  fullNameOverride: null

  ## Define serviceAccount names. Defaults to fully qualified name.
  ##
  serviceAccount:
    create: true
    name:
    annotations: {}

  ## ConfigMap override where fullname is {{.Release.Name}}-{{.Values.node.configMapOverrideName}}
  ## Defining configMapOverrideName will cause templates/node/configmap.yaml
  ## to NOT generate a ConfigMap resource
  ##
  configMapOverrideName: ""

  ## ConfigMap entries
  ##
  config:
    thingsboard.yml:
      server:
        # Server bind address
        address: "0.0.0.0"
        # Server bind port
        port: "8080"
        # Server SSL configuration
        ssl:
          # Enable/disable SSL support
          enabled: "false"
          # Path to the key store that holds the SSL certificate
          key-store: "classpath:keystore/keystore.p12"
          # Password used to access the key store
          key-store-password: "thingsboard"
          # Type of the key store
          key-store-type: "PKCS12"
          # Alias that identifies the key in the key store
          key-alias: "tomcat"
        log_controller_error_stack_trace: "true"
        ws:
          send_timeout: "5000"
          limits:
            # Limit the amount of sessions and subscriptions available on each server. Put values to zero to disable particular limitation
            max_sessions_per_tenant: "0"
            max_sessions_per_customer: "0"
            max_sessions_per_regular_user: "0"
            max_sessions_per_public_user: "0"
            max_queue_per_ws_session: "500"
            max_subscriptions_per_tenant: "0"
            max_subscriptions_per_customer: "0"
            max_subscriptions_per_regular_user: "0"
            max_subscriptions_per_public_user: "0"
            max_updates_per_session: "300:1,3000:60"
        rest:
          limits:
            tenant:
              enabled: "false"
              configuration: "100:1,2000:60"
            customer:
              enabled: "false"
              configuration: "50:1,1000:60"

      # Zookeeper connection parameters. Used for service discovery.
      zk:
        # Enable/disable zookeeper discovery service.
        enabled: "false"
        # Zookeeper connect string
        url: "localhost:2181"
        # Zookeeper retry interval in milliseconds
        retry_interval_ms: "3000"
        # Zookeeper connection timeout in milliseconds
        connection_timeout_ms: "3000"
        # Zookeeper session timeout in milliseconds
        session_timeout_ms: "3000"
        # Name of the directory in zookeeper 'filesystem'
        zk_dir: "/thingsboard"

      # RPC connection parameters. Used only in cluster mode only.
      rpc:
        bind_host: "${RPC_HOST:localhost}"
        bind_port: "9001"

      # Clustering properties related to consistent-hashing. See architecture docs for more details.
      cluster:
        # Unique id for this node (autogenerated if empty)
        node_id: "${CLUSTER_NODE_ID:}"
        # Name of hash function used for consistent hash ring.
        hash_function_name: "murmur3_128"
        # Amount of virtual nodes in consistent hash ring.
        vitrual_nodes_size: "16"
        # Queue partition id for current node
        partition_id: "0"
        stats:
          enabled: "false"
          print_interval_ms: "10000"

      # Plugins configuration parameters
      plugins:
        # Comma separated package list used during classpath scanning for plugins
        scan_packages: "org.thingsboard.server.extensions,org.thingsboard.rule.engine"

      # Security parameters
      security:
        # JWT Token parameters
        jwt:
          tokenExpirationTime: "9000" # Number of seconds (2.5 hours)
          refreshTokenExpTime: "604800" # Number of seconds (1 week)
          tokenIssuer: "thingsboard.io"
          tokenSigningKey: "thingsboardDefaultSigningKey"
        # Enable/disable access to Tenant Administrators JWT token by System Administrator or Customer Users JWT token by Tenant Administrator
        user_token_access_enabled: "true"
        # Enable/disable case-sensitive username login
        user_login_case_sensitive: "true"
        claim:
          # Enable/disable claiming devices, if false -> the device's [claimingAllowed] SERVER_SCOPE attribute must be set to [true] to allow claiming specific device
          allowClaimingByDefault: "true"
          # Time allowed to claim the device in milliseconds
          duration: "60000" # 1 minute, note this value must equal claimDevices.timeToLiveInMinutes value

      # Dashboard parameters
      dashboard:
        # Maximum allowed datapoints fetched by widgets
        max_datapoints_limit: "50000"

      database:
        ts_max_intervals: "700" # Max number of DB queries generated by single API call to fetch telemetry records
        entities:
          type: "sql" # cassandra OR sql
        ts:
          type: "sql" # cassandra, sql, or timescale (for hybrid mode, DATABASE_TS_TYPE value should be cassandra, or timescale)

      # note: timescale works only with postgreSQL database for DATABASE_ENTITIES_TYPE.

      # Cassandra driver configuration parameters
      cassandra:
        # Thingsboard cluster name
        cluster_name: "Thingsboard Cluster"
        # Thingsboard keyspace name
        keyspace_name: "thingsboard"
        # Specify node list
        url: "127.0.0.1:9042"
        # Enable/disable secure connection
        ssl: "false"
        # Enable/disable JMX
        jmx: "true"
        # Enable/disable metrics collection.
        metrics: "true"
        # NONE SNAPPY LZ4
        compression: "none"
        # Specify cassandra cluster initialization timeout in milliseconds (if no hosts available during startup)
        init_timeout_ms: "300000"
        # Specify cassandra claster initialization retry interval (if no hosts available during startup)
        init_retry_interval_ms: "3000"
        max_requests_per_connection_local: "32768"
        max_requests_per_connection_remote: "32768"
        # Credential parameters #
        credentials: "false"
        # Specify your username
        username: ""
        # Specify your password
        password: ""

        # Cassandra cluster connection socket parameters #
        socket:
          connect_timeout: "5000"
          read_timeout: "20000"
          keep_alive: "true"
          reuse_address: "true"
          so_linger: ""
          tcp_no_delay: "false"
          receive_buffer_size: ""
          send_buffer_size: ""

        # Cassandra cluster connection query parameters  #
        query:
          read_consistency_level: "ONE"
          write_consistency_level: "ONE"
          default_fetch_size: "2000"
          # Specify partitioning size for timestamp key-value storage. Example MINUTES, HOURS, DAYS, MONTHS,INDEFINITE
          ts_key_value_partitioning: "MONTHS"
          ts_key_value_ttl: "0"
          events_ttl: "0"
          # Specify TTL of debug log in seconds. The current value corresponds to one week
          debug_events_ttl: "604800"
          buffer_size: "200000"
          concurrent_limit: "1000"
          permit_max_wait_time: "120000"
          dispatcher_threads: "2"
          callback_threads: "4"
          poll_ms: "50"
          rate_limit_print_interval_ms: "10000"
          # set all data types values except target to null for the same ts on save
          set_null_values_enabled: "false"
          # log one of cassandra queries with specified frequency (0 - logging is disabled)
          print_queries_freq: "0"
          tenant_rate_limits:
            enabled: "false"
            configuration: "1000:1,30000:60"
            print_tenant_names: "false"

      # SQL configuration parameters
      sql:
        # Specify batch size for persisting attribute updates
        attributes:
          batch_size: "10000"
          batch_max_delay: "100"
          stats_print_interval_ms: "10000"
        ts:
          batch_size: "10000"
          batch_max_delay: "100"
          stats_print_interval_ms: "10000"
        ts_latest:
          batch_size: "10000"
          batch_max_delay: "100"
          stats_print_interval_ms: "10000"
        ts_timescale:
          batch_size: "10000"
          batch_max_delay: "100"
          stats_print_interval_ms: "10000"
        # Specify whether to remove null characters from strValue of attributes and timeseries before insert
        remove_null_chars: "true"

      # Actor system parameters
      actors:
        cluster:
          grpc_callback_thread_pool_size: "10"
        tenant:
          create_components_on_init: "true"
        session:
          max_concurrent_sessions_per_device: "1"
          sync:
            # Default timeout for processing request using synchronous session (HTTP, CoAP) in milliseconds
            timeout: "10000"
        rule:
          # Specify thread pool size for database request callbacks executor service
          db_callback_thread_pool_size: "50"
          # Specify thread pool size for javascript executor service
          js_thread_pool_size: "50"
          # Specify thread pool size for mail sender executor service
          mail_thread_pool_size: "50"
          # Whether to allow usage of system mail service for rules
          allow_system_mail_service: "true"
          # Specify thread pool size for external call service
          external_call_thread_pool_size: "50"
          chain:
            # Errors for particular actor are persisted once per specified amount of milliseconds
            error_persist_frequency: "3000"
            debug_mode_rate_limits_per_tenant:
              enabled: "true"
              configuration: "50000:3600"
          node:
            # Errors for particular actor are persisted once per specified amount of milliseconds
            error_persist_frequency: "3000"
          transaction:
            # Size of queues which store messages for transaction rule nodes
            queue_size: "20"
            # Time in milliseconds for transaction to complete
            duration: "15000"
        statistics:
          # Enable/disable actor statistics
          enabled: "true"
          js_print_interval_ms: "10000"
          persist_frequency: "3600000"
        queue:
          # Enable/disable persistence of un-processed messages to the queue
          enabled: "true"
          # Maximum allowed timeout for persistence into the queue
          timeout: "30000"
        client_side_rpc:
          timeout:  "60000"

      cache:
        # caffeine or redis
        type: "caffeine"

      caffeine:
        specs:
          relations:
            timeToLiveInMinutes: 1440
            maxSize: 100000
          deviceCredentials:
            timeToLiveInMinutes: 1440
            maxSize: 100000
          devices:
            timeToLiveInMinutes: 1440
            maxSize: 100000
          sessions:
            timeToLiveInMinutes: 1440
            maxSize: 100000
          assets:
            timeToLiveInMinutes: 1440
            maxSize: 100000
          entityViews:
            timeToLiveInMinutes: 1440
            maxSize: 100000
          claimDevices:
            timeToLiveInMinutes: 1
            maxSize: 100000
          securitySettings:
            timeToLiveInMinutes: 1440
            maxSize: 1

      redis:
        # standalone or cluster
        connection:
          type: standalone
        standalone:
          host: "localhost"
          port: "6379"
          useDefaultClientConfig: "true"
          # this value may be used only if you used not default ClientConfig
          clientName: "standalone"
          # this value may be used only if you used not default ClientConfig
          connectTimeout: "30000"
          # this value may be used only if you used not default ClientConfig
          readTimeout: "60000"
          # this value may be used only if you used not default ClientConfig
          usePoolConfig: "false"
        cluster:
          # Comma-separated list of "host:port" pairs to bootstrap from.
          nodes: ""
          # Maximum number of redirects to follow when executing commands across the cluster.
          max-redirects: "12"
          useDefaultPoolConfig: "true"
        # db index
        db: "0"
        # db password
        password: ""
        # pool config
        pool_config:
          maxTotal: "128"
          maxIdle: "128"
          minIdle: "16"
          testOnBorrow: "true"
          testOnReturn: "true"
          testWhileIdle: "true"
          minEvictableMs: "60000"
          evictionRunsMs: "30000"
          maxWaitMills: "60000"
          numberTestsPerEvictionRun: "3"
          blockWhenExhausted: "true"

      # Check new version updates parameters
      updates:
        # Enable/disable updates checking.
        enabled: "true"

      # spring CORS configuration
      spring.mvc.cors:
        mappings:
          # Intercept path
          "[/api/**]":
            #Comma-separated list of origins to allow. '*' allows all origins. When not set,CORS support is disabled.
            allowed-origins: "*"
            #Comma-separated list of methods to allow. '*' allows all methods.
            allowed-methods: "*"
            #Comma-separated list of headers to allow in a request. '*' allows all headers.
            allowed-headers: "*"
            #How long, in seconds, the response from a pre-flight request can be cached by clients.
            max-age: "1800"
            #Set whether credentials are supported. When not set, credentials are not supported.
            allow-credentials: "true"

      # spring serve gzip compressed static resources
      spring.resources.chain:
        compressed: "true"
        strategy:
          content:
            enabled: "true"

      spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation: "true"

      # SQL DAO Configuration
      spring:
        data:
          jpa:
            repositories:
              enabled: "true"
        jpa:
          open-in-view: "false"
          hibernate:
            ddl-auto: "none"
          database-platform: "org.hibernate.dialect.PostgreSQLDialect"
        datasource:
          driverClassName: "org.postgresql.Driver"
          url: "jdbc:postgresql://localhost:5432/thingsboard"
          username: "postgres"
          password: "postgres"
          hikari:
            maximumPoolSize: "50"

      # Audit log parameters
      audit-log:
        # Enable/disable audit log functionality.
        enabled: "true"
        # Specify partitioning size for audit log by tenant id storage. Example MINUTES, HOURS, DAYS, MONTHS
        by_tenant_partitioning: "MONTHS"
        # Number of days as history period if startTime and endTime are not specified
        default_query_period: "30"
        # Logging levels per each entity type.
        # Allowed values: OFF (disable), W (log write operations), RW (log read and write operations)
        logging-level:
          mask:
            "device": "W"
            "asset": "W"
            "dashboard": "W"
            "customer": "W"
            "user": "W"
            "rule_chain": "W"
            "alarm": "W"
            "entity_view": "W"
        sink:
          # Type of external sink. possible options: none, elasticsearch
          type: "none"
          # Name of the index where audit logs stored
          # Index name could contain next placeholders (not mandatory):
          # @{TENANT} - substituted by tenant ID
          # @{DATE} - substituted by current date in format provided in audit_log.sink.date_format
          index_pattern: "@{TENANT}_AUDIT_LOG_@{DATE}"
          # Date format. Details of the pattern could be found here:
          # https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html
          date_format: "YYYY.MM.DD"
          scheme_name: "http" # http or https
          host: "localhost"
          port: "9200"
          user_name: ""
          password: ""

      state:
        defaultInactivityTimeoutInSec: "10"
        defaultStateCheckIntervalInSec: "10"
        persistToTelemetry: "false"

      kafka:
        enabled: true
        bootstrap.servers: "localhost:9092"
        acks: "all"
        retries: "1"
        batch.size: "16384"
        linger.ms: "1"
        buffer.memory: "33554432"
        transport_api:
          requests_topic: "tb.transport.api.requests"
          responses_topic: "tb.transport.api.responses"
          max_pending_requests: "10000"
          max_requests_timeout: "10000"
          request_poll_interval: "25"
          request_auto_commit_interval: "100"
        rule_engine:
          topic: "tb.rule-engine"
          poll_interval: "25"
          auto_commit_interval: "100"
        notifications:
          topic: "tb.transport.notifications"

      js:
        evaluator: "local" # local/remote
        # Built-in JVM JavaScript environment properties
        local:
          # Use Sandboxed (secured) JVM JavaScript environment
          use_js_sandbox: "true"
          # Specify thread pool size for JavaScript sandbox resource monitor
          monitor_thread_pool_size: "4"
          # Maximum CPU time in milliseconds allowed for script execution
          max_cpu_time: "3000"
          # Maximum allowed JavaScript execution errors before JavaScript will be blacklisted
          max_errors: "3"
          # JS Eval max request timeout. 0 - no timeout
          max_requests_timeout: "0"
          stats:
            enabled: "false"
            print_interval_ms: "10000"
        # Remote JavaScript environment properties
        remote:
          # JS Eval request topic
          request_topic: "js.eval.requests"
          # JS Eval responses topic prefix that is combined with node id
          response_topic_prefix: "js.eval.responses"
          # JS Eval max pending requests
          max_pending_requests: "10000"
          # JS Eval max request timeout
          max_requests_timeout: "10000"
          # JS response poll interval
          response_poll_interval: "25"
          # JS response auto commit interval
          response_auto_commit_interval: "100"
          # Maximum allowed JavaScript execution errors before JavaScript will be blacklisted
          max_errors: "3"
          stats:
            enabled: "false"
            print_interval_ms: "10000"

      transport:
        type: "local" # local or remote
        remote:
          transport_api:
            requests_topic: "tb.transport.api.requests"
            max_pending_requests: "10000"
            request_timeout: "10000"
            request_poll_interval: "25"
            request_auto_commit_interval: "1000"
          rule_engine:
            topic: "tb.rule-engine"
            poll_interval: "25"
            auto_commit_interval: "100"
            poll_records_pack_size: "1000"
            max_poll_records_per_second: "10000"
            max_poll_records_per_minute: "120000"
            stats:
              enabled: "false"
              print_interval_ms: "10000"
          notifications:
            topic: "tb.transport.notifications"
        sessions:
          inactivity_timeout: "300000"
          report_timeout: "30000"
        rate_limits:
          enabled: "false"
          tenant: "1000:1,20000:60"
          device: "10:1,300:60"
        json:
          # Cast String data types to Numeric if possible when processing Telemetry/Attributes JSON
          type_cast_enabled: "true"
          # Maximum allowed string value length when processing Telemetry/Attributes JSON (0 value disables string value length check)
          max_string_value_length: "0"
        # Local HTTP transport parameters
        http:
          enabled: "true"
          request_timeout: "60000"
        # Local MQTT transport parameters
        mqtt:
          # Enable/disable mqtt transport protocol.
          enabled: "true"
          bind_address: "0.0.0.0"
          bind_port: "1883"
          timeout: "10000"
          netty:
            leak_detector_level: "DISABLED"
            boss_group_thread_count: "1"
            worker_group_thread_count: "12"
            max_payload_size: "65536"
            so_keep_alive: "false"
          # MQTT SSL configuration
          ssl:
            # Enable/disable SSL support
            enabled: "false"
            # SSL protocol: See http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#SSLContext
            protocol: "TLSv1.2"
            # Path to the key store that holds the SSL certificate
            key_store: "mqttserver.jks"
            # Password used to access the key store
            key_store_password: "server_ks_password"
            # Password used to access the key
            key_password: "server_key_password"
            # Type of the key store
            key_store_type: "JKS"
        # Local CoAP transport parameters
        coap:
          # Enable/disable coap transport protocol.
          enabled: "true"
          bind_address: "0.0.0.0"
          bind_port: "5683"
          timeout: "10000"

      swagger:
        api_path_regex: "/api.*"
        security_path_regex: "/api.*"
        non_security_path_regex: "/api/noauth.*"
        title: "Thingsboard REST API"
        description: "For instructions how to authorize requests please visit <a href='http://thingsboard.io/docs/reference/rest-api/'>REST API documentation page</a>."
        contact:
          name: "Thingsboard team"
          url: "http://thingsboard.io"
          email: "info@thingsboard.io"
        license:
          title: "Apache License Version 2.0"
          url: "https://github.com/thingsboard/thingsboard/blob/master/LICENSE"
        version: "2.0"

    logback.xml: |
      <!DOCTYPE configuration>
            <configuration scan="true" scanPeriod="10 seconds">
                <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
                    <encoder>
                        <pattern>%d{ISO8601} [%thread] %-5level %logger{36} - %msg%n</pattern>
                    </encoder>
                </appender>

                <logger name="org.thingsboard.server" level="INFO" />
                <logger name="com.google.common.util.concurrent.AggregateFuture" level="OFF" />

                <root level="INFO">
                    <appender-ref ref="STDOUT"/>
                </root>
            </configuration>
    thingsboard.conf: |
      export JAVA_OPTS="$JAVA_OPTS -Dspring.config.location=/usr/share/thingsboard/conf/,/usr/share/thingsboard/extensions/,/config/"
      export JAVA_OPTS="$JAVA_OPTS -Dplatform=deb -Dinstall.data_dir=/usr/share/thingsboard/data"
      export LOG_FILENAME=/dev/stdout
      export LOADER_PATH=""

  livenessProbe:
    initialDelay: 300
    periodSeconds: 15
    timeoutSeconds: 10
    failureThreshold: 3
    successThreshold: 1

  image:
    repository: thingsboard/tb-node
    pullPolicy: IfNotPresent

  ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
  ##
  podSecurityPolicy:
    annotations: {}
      ## Specify pod annotations
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#apparmor
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#sysctl
      ##
      # seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
      # seccomp.security.alpha.kubernetes.io/defaultProfileName: 'docker/default'
      # apparmor.security.beta.kubernetes.io/defaultProfileName: 'runtime/default'

  priorityClassName: ""

  updateStrategy:
    type: RollingUpdate

  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  ##
  tolerations: []
    # - key: "key"
    #   operator: "Equal|Exists"
    #   value: "value"
    #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}

  ## Annotations to be added to pods
  ##
  podAnnotations: {}

  ## Labels to be added to pods
  ##
  pod:
    labels: {}

  ## PodDisruptionBudget settings
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
  ##
  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1

  ## Ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources: {}
    # limits:
    #   cpu: 200m
    #   memory: 50Mi
    # requests:
    #   cpu: 100m
  #   memory: 30Mi

  ## Security context to be added to node-exporter pods
  ##
  securityContext: {}
  # runAsUser: 0

  service:
    servicePort:
      name: http
      port: 8080
      targetPort: http
      protocol: TCP

    annotations:
      prometheus.io/scrape: "true"
    labels: {}
    type: ClusterIP

  ingress:
    ## If true, Ingress will be created
    ##
    enabled: false

    ## Ingress annotations
    ##
    annotations: {}
    #   kubernetes.io/ingress.class: nginx
    #   kubernetes.io/tls-acme: 'true'

    ## Ingress additional labels
    ##
    extraLabels: {}

    ## Ingress hostname
    ## Must be provided if Ingress is enabled
    ##
    host: ""
    paths:
      - /api
      - /swagger
      - /webjars
      - /v2
      - /static/rulenode
      - /oauth2
      - /login/oauth2

    ## Ingress TLS configuration
    ##
    tls: false

web:
  enabled: true
  kind: Deployment
  # only used if kind is Deployment
  replicas: 1
  name: tb-web-ui
  nameOverride: null
  fullNameOverride: null

  ## Define serviceAccount names. Defaults to fully qualified name.
  ##
  serviceAccount:
    create: true
    name:
    annotations: {}

  ## ConfigMap override where fullname is {{.Release.Name}}-{{.Values.node.configMapOverrideName}}
  ## Defining configMapOverrideName will cause templates/node/configmap.yaml
  ## to NOT generate a ConfigMap resource
  ##
  configMapOverrideName: ""

  ## ConfigMap entries
  ##
  config:
    tb-web-ui.conf: |
      export NODE_CONFIG_DIR=/usr/share/tb-web-ui/conf
      export DOCKER_MODE=true
      export WEB_FOLDER=/usr/share/tb-web-ui/web
      export NODE_ENV=default
    default.yml:
      server:
        # Server bind address
        address: "0.0.0.0"
        # Server bind port
        port: "8080"
      thingsboard:
        enableProxy: "false"
        # ThingsBoard node host
        host: "localhost"
        # ThingsBoard node port
        port: "8080"
      logger:
        level: "info"
        path: "logs"
        filename: "tb-web-ui-%DATE%.log"
    logger.js: |
      var config = require('config'),
          path = require('path'),
          DailyRotateFile = require('winston-daily-rotate-file');

      const { createLogger, format, transports } = require('winston');
      const { combine, timestamp, label, printf, splat } = format;

      var loggerTransports = [];

      if (process.env.NODE_ENV !== 'production' || process.env.DOCKER_MODE === 'true') {
          loggerTransports.push(new transports.Console({
              handleExceptions: true
          }));
      } else {
          var filename = path.join(config.get('logger.path'), config.get('logger.filename'));
          var transport = new (DailyRotateFile)({
              filename: filename,
              datePattern: 'YYYY-MM-DD-HH',
              zippedArchive: true,
              maxSize: '20m',
              maxFiles: '14d',
              handleExceptions: true
          });
          loggerTransports.push(transport);
      }

      const tbFormat = printf(info => {
          return `$${info.timestamp} [$${info.label}] $${info.level.toUpperCase()}: $${info.message}`;
      });

      function _logger(moduleLabel) {
          return createLogger({
              level: config.get('logger.level'),
              format:combine(
                  splat(),
                  label({ label: moduleLabel }),
                  timestamp({format: 'YYYY-MM-DD HH:mm:ss,SSS'}),
                  tbFormat
              ),
              transports: loggerTransports
          });
      }
  livenessProbe:
    initialDelay: 300
    periodSeconds: 15
    timeoutSeconds: 10
    failureThreshold: 3
    successThreshold: 1

  image:
    repository: thingsboard/tb-web-ui
    pullPolicy: IfNotPresent

  ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
  ##
  podSecurityPolicy:
    annotations: {}
      ## Specify pod annotations
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#apparmor
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#sysctl
      ##
      # seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
      # seccomp.security.alpha.kubernetes.io/defaultProfileName: 'docker/default'
    # apparmor.security.beta.kubernetes.io/defaultProfileName: 'runtime/default'

  priorityClassName: ""

  updateStrategy:
    type: RollingUpdate

  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  ##
  tolerations: []
    # - key: "key"
    #   operator: "Equal|Exists"
    #   value: "value"
  #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}

  ## Annotations to be added to pods
  ##
  podAnnotations: {}

  ## Labels to be added to pods
  ##
  pod:
    labels: {}

  ## PodDisruptionBudget settings
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
  ##
  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1

  ## Ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources: {}
    # limits:
    #   cpu: 200m
    #   memory: 50Mi
    # requests:
  #   cpu: 100m
  #   memory: 30Mi

  ## Security context to be added to node-exporter pods
  ##
  securityContext: {}
  # runAsUser: 0

  service:
    servicePort:
      name: http
      port: 8080
      targetPort: http
      protocol: TCP

    annotations:
      prometheus.io/scrape: "true"
    labels: {}
    type: ClusterIP

  ingress:
    ## If true, Ingress will be created
    ##
    enabled: false

    ## Ingress annotations
    ##
    annotations: {}
    #   kubernetes.io/ingress.class: nginx
    #   kubernetes.io/tls-acme: 'true'

    ## Ingress additional labels
    ##
    extraLabels: {}

    ## Ingress hostname
    ## Must be provided if Ingress is enabled
    ##
    host: ""
    paths:
      - /static/
      - /index.html
      - /

    ## Ingress TLS configuration
    ##
    tls: false

js:
  enabled: false
  kind: Deployment
  # only used if kind is Deployment
  replicas: 1
  name: tb-js-executor
  nameOverride: null
  fullNameOverride: null

  env: {}

  ## Define serviceAccount names. Defaults to fully qualified name.
  ##
  serviceAccount:
    create: true
    name:
    annotations: {}

  ## ConfigMap override where fullname is {{.Release.Name}}-{{.Values.node.configMapOverrideName}}
  ## Defining configMapOverrideName will cause templates/node/configmap.yaml
  ## to NOT generate a ConfigMap resource
  ##
  configMapOverrideName: ""

  image:
    repository: thingsboard/tb-js-executor
    pullPolicy: IfNotPresent

  ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
  ##
  podSecurityPolicy:
    annotations: {}
      ## Specify pod annotations
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#apparmor
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
    ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#sysctl
    ##
    # seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
    # seccomp.security.alpha.kubernetes.io/defaultProfileName: 'docker/default'
    # apparmor.security.beta.kubernetes.io/defaultProfileName: 'runtime/default'

  priorityClassName: ""

  updateStrategy:
    type: RollingUpdate

  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  ##
  tolerations: []
  # - key: "key"
  #   operator: "Equal|Exists"
  #   value: "value"
  #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

  ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}

  ## Annotations to be added to pods
  ##
  podAnnotations: {}

  ## Labels to be added to pods
  ##
  pod:
    labels: {}

  ## PodDisruptionBudget settings
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
  ##
  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1

  ## Ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources: {}
  # limits:
  #   cpu: 200m
  #   memory: 50Mi
  # requests:
  #   cpu: 100m
  #   memory: 30Mi

  ## Security context to be added to node-exporter pods
  ##
  securityContext: {}
  # runAsUser: 0

transport:
  http:
    enabled: false
    kind: Deployment
    # only used if kind is Deployment
    replicas: 1
    name: tb-http-transport
    nameOverride: null
    fullNameOverride: null

    ## Define serviceAccount names. Defaults to fully qualified name.
    ##
    serviceAccount:
      create: true
      name:
      annotations: {}

    ## ConfigMap override where fullname is {{.Release.Name}}-{{.Values.node.configMapOverrideName}}
    ## Defining configMapOverrideName will cause templates/node/configmap.yaml
    ## to NOT generate a ConfigMap resource
    ##
    configMapOverrideName: ""

    ## ConfigMap entries
    ##
    config:
      tb-http-transport.conf: |
        export JAVA_OPTS="$JAVA_OPTS -Dspring.config.location=/usr/share/tb-http-transport/conf/,/config/"
        export LOG_FILENAME=/dev/stdout
        export LOADER_PATH=""
      logback.xml: |
        <?xml version="1.0" encoding="UTF-8" ?>
        <!--

            Copyright © 2016-2020 The Thingsboard Authors

            Licensed under the Apache License, Version 2.0 (the "License");
            you may not use this file except in compliance with the License.
            You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

            Unless required by applicable law or agreed to in writing, software
            distributed under the License is distributed on an "AS IS" BASIS,
            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            See the License for the specific language governing permissions and
            limitations under the License.

        -->
        <!DOCTYPE configuration>
        <configuration scan="true" scanPeriod="10 seconds">

            <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
                <encoder>
                    <pattern>%d{ISO8601} [%thread] %-5level %logger{36} - %msg%n</pattern>
                </encoder>
            </appender>

            <logger name="org.thingsboard.server" level="TRACE" />

            <logger name="com.microsoft.azure.servicebus.primitives.CoreMessageReceiver" level="OFF" />

            <root level="INFO">
                <appender-ref ref="STDOUT"/>
            </root>

        </configuration>
      tb-http-transport.yml:
        server:
          # Server bind address
          address: "0.0.0.0"
          # Server bind port
          port: "8080"

        # Clustering properties
        cluster:
          # Unique id for this node (autogenerated if empty)
          node_id: "${CLUSTER_NODE_ID:}"

        # HTTP server parameters
        transport:
          http:
            request_timeout: "60000"
          sessions:
            inactivity_timeout: "300000"
            report_timeout: "30000"
          rate_limits:
            enabled: "false"
            tenant: "1000:1,20000:60"
            device: "10:1,300:60"
          json:
            # Cast String data types to Numeric if possible when processing Telemetry/Attributes JSON
            type_cast_enabled: "true"
            # Maximum allowed string value length when processing Telemetry/Attributes JSON (0 value disables string value length check)
            max_string_value_length: "0"

        kafka:
          enabled: true
          bootstrap.servers: "localhost:9092"
          acks: "all"
          retries: "1"
          batch.size: "16384"
          linger.ms: "1"
          buffer.memory: "33554432"
          transport_api:
            requests_topic: "tb.transport.api.requests"
            responses_topic: "tb.transport.api.responses"
            max_pending_requests: "10000"
            max_requests_timeout: "10000"
            response_poll_interval: "25"
            response_auto_commit_interval: "100"
          rule_engine:
            topic: "tb.rule-engine"
          notifications:
            topic: "tb.transport.notifications"
            poll_interval: "25"
            auto_commit_interval: "100"


    livenessProbe:
      initialDelay: 120
      periodSeconds: 20
      timeoutSeconds: 10
      failureThreshold: 3
      successThreshold: 1

    image:
      repository: thingsboard/tb-http-transport
      pullPolicy: IfNotPresent

    ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
    ##
    podSecurityPolicy:
      annotations: {}
        ## Specify pod annotations
        ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#apparmor
        ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
        ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#sysctl
        ##
      # seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
      # seccomp.security.alpha.kubernetes.io/defaultProfileName: 'docker/default'
      # apparmor.security.beta.kubernetes.io/defaultProfileName: 'runtime/default'

    priorityClassName: ""

    updateStrategy:
      type: RollingUpdate

    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    ##
    tolerations: []
      # - key: "key"
    #   operator: "Equal|Exists"
    #   value: "value"
    #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

    ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
    ##
    nodeSelector: {}

    ## Annotations to be added to pods
    ##
    podAnnotations: {}

    ## Labels to be added to pods
    ##
    pod:
      labels: {}

    ## PodDisruptionBudget settings
    ## ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
    ##
    podDisruptionBudget:
      enabled: false
      maxUnavailable: 1

    ## Ref: https://kubernetes.io/docs/user-guide/compute-resources/
    ##
    resources: {}
      # limits:
      #   cpu: 200m
    #   memory: 50Mi
    # requests:
    #   cpu: 100m
    #   memory: 30Mi

    ## Security context to be added to node-exporter pods
    ##
    securityContext: {}
    # runAsUser: 0

    service:
      servicePort:
        name: http
        port: 8080
        targetPort: http
        protocol: TCP

      annotations:
        prometheus.io/scrape: "true"
      labels: {}
      type: ClusterIP

    ingress:
      ## If true, Ingress will be created
      ##
      enabled: false

      ## Ingress annotations
      ##
      annotations: {}
      #   kubernetes.io/ingress.class: nginx
      #   kubernetes.io/tls-acme: 'true'

      ## Ingress additional labels
      ##
      extraLabels: {}

      ## Ingress hostname
      ## Must be provided if Ingress is enabled
      ##
      host: ""
      paths:
        - /api/v1

      ## Ingress TLS configuration
      ##
      tls: false

  mqtt:
    enabled: false
    kind: Deployment
    # only used if kind is Deployment
    replicas: 1
    name: tb-mqtt-transport
    nameOverride: null
    fullNameOverride: null

    ## Define serviceAccount names. Defaults to fully qualified name.
    ##
    serviceAccount:
      create: true
      name:
      annotations: {}

    ## ConfigMap override where fullname is {{.Release.Name}}-{{.Values.node.configMapOverrideName}}
    ## Defining configMapOverrideName will cause templates/node/configmap.yaml
    ## to NOT generate a ConfigMap resource
    ##
    configMapOverrideName: ""

    ## ConfigMap entries
    ##
    config:
      tb-mqtt-transport.conf: |
        export JAVA_OPTS="$JAVA_OPTS -Dspring.config.location=/usr/share/tb-mqtt-transport/conf/,/config/"
        export LOG_FILENAME=/dev/stdout
        export LOADER_PATH=""
      logback.xml: |
        <?xml version="1.0" encoding="UTF-8" ?>
        <!--

            Copyright © 2016-2020 The Thingsboard Authors

            Licensed under the Apache License, Version 2.0 (the "License");
            you may not use this file except in compliance with the License.
            You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

            Unless required by applicable law or agreed to in writing, software
            distributed under the License is distributed on an "AS IS" BASIS,
            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
            See the License for the specific language governing permissions and
            limitations under the License.

        -->
        <!DOCTYPE configuration>
        <configuration scan="true" scanPeriod="10 seconds">

            <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
                <encoder>
                    <pattern>%d{ISO8601} [%thread] %-5level %logger{36} - %msg%n</pattern>
                </encoder>
            </appender>

            <logger name="org.thingsboard.server" level="TRACE" />

            <logger name="com.microsoft.azure.servicebus.primitives.CoreMessageReceiver" level="OFF" />

            <root level="INFO">
                <appender-ref ref="STDOUT"/>
            </root>

        </configuration>
      tb-mqtt-transport.yml:
        spring.main.web-environment: false
        spring.main.web-application-type: none

        # Clustering properties
        cluster:
          # Unique id for this node (autogenerated if empty)
          node_id: "${CLUSTER_NODE_ID:}"

        # MQTT server parameters
        transport:
          mqtt:
            bind_address: "0.0.0.0"
            bind_port: "1883"
            adaptor: "JsonMqttAdaptor"
            timeout: "10000"
            netty:
              leak_detector_level: "DISABLED"
              boss_group_thread_count: "1"
              worker_group_thread_count: "12"
              max_payload_size: "65536"
              so_keep_alive: "false"
            # MQTT SSL configuration
            ssl:
              # Enable/disable SSL support
              enabled: "false"
              # SSL protocol: See http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#SSLContext
              protocol: "TLSv1.2"
              # Path to the key store that holds the SSL certificate
              key_store: "mqttserver.jks"
              # Password used to access the key store
              key_store_password: "server_ks_password"
              # Password used to access the key
              key_password: "server_key_password"
              # Type of the key store
              key_store_type: "JKS"
          sessions:
            inactivity_timeout: "300000"
            report_timeout: "30000"
          rate_limits:
            enabled: "false"
            tenant: "1000:1,20000:60"
            device: "10:1,300:60"
          json:
            # Cast String data types to Numeric if possible when processing Telemetry/Attributes JSON
            type_cast_enabled: "true"
            # Maximum allowed string value length when processing Telemetry/Attributes JSON (0 value disables string value length check)
            max_string_value_length: "0"

        kafka:
          enabled: true
          bootstrap.servers: "localhost:9092"
          acks: "all"
          retries: "1"
          batch.size: "16384"
          linger.ms: "1"
          buffer.memory: "33554432"
          transport_api:
            requests_topic: "tb.transport.api.requests"
            responses_topic: "tb.transport.api.responses"
            max_pending_requests: "10000"
            max_requests_timeout: "10000"
            response_poll_interval: "25"
            response_auto_commit_interval: "100"
          rule_engine:
            topic: "tb.rule-engine"
          notifications:
            topic: "tb.transport.notifications"
            poll_interval: "25"
            auto_commit_interval: "100"

    livenessProbe:
      initialDelay: 300
      periodSeconds: 15
      timeoutSeconds: 10
      failureThreshold: 3
      successThreshold: 1

    image:
      repository: thingsboard/tb-mqtt-transport
      pullPolicy: IfNotPresent

    ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
    ##
    podSecurityPolicy:
      annotations: {}
        ## Specify pod annotations
        ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#apparmor
        ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp
      ## Ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/#sysctl
      ##
      # seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
      # seccomp.security.alpha.kubernetes.io/defaultProfileName: 'docker/default'
      # apparmor.security.beta.kubernetes.io/defaultProfileName: 'runtime/default'

    priorityClassName: ""

    updateStrategy:
      type: RollingUpdate

    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    ##
    tolerations: []
    # - key: "key"
    #   operator: "Equal|Exists"
    #   value: "value"
    #   effect: "NoSchedule|PreferNoSchedule|NoExecute(1.6 only)"

    ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
    ##
    nodeSelector: {}

    ## Annotations to be added to pods
    ##
    podAnnotations: {}

    ## Labels to be added to pods
    ##
    pod:
      labels: {}

    ## PodDisruptionBudget settings
    ## ref: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/
    ##
    podDisruptionBudget:
      enabled: false
      maxUnavailable: 1

    ## Ref: https://kubernetes.io/docs/user-guide/compute-resources/
    ##
    resources: {}
    # limits:
    #   cpu: 200m
    #   memory: 50Mi
    # requests:
    #   cpu: 100m
    #   memory: 30Mi

    ## Security context to be added to node-exporter pods
    ##
    securityContext: {}
    # runAsUser: 0

    service:
      servicePort:
        name: mqtt
        port: 1883
        targetPort: mqtt
        protocol: TCP

      annotations:
        prometheus.io/scrape: "true"
      labels: {}
      type: ClusterIP

    ingress:
      ## If true, Ingress will be created
      ##
      enabled: false

      ## Ingress annotations
      ##
      annotations: {}
      #   kubernetes.io/ingress.class: nginx
      #   kubernetes.io/tls-acme: 'true'

      ## Ingress additional labels
      ##
      extraLabels: {}

      ## Ingress hostname
      ## Must be provided if Ingress is enabled
      ##
      host: ""
      paths:
        - /static/
        - /index.html
        - /

      ## Ingress TLS configuration
      ##
      tls: false
